# ğŸ“š Backend API Documentation (Multi-Agent System)

This API provides a real-time streaming interface for the Multi-Agent Orchestrator. It uses **Server-Sent Events (SSE)** to stream agent thoughts, tool calls, and final answers token-by-token.

It also supports **Human-in-the-Loop (HITL)** workflows, allowing the backend to pause execution (e.g., for email review) and wait for the frontend to send user approval.

## ğŸš€ Base URL
`http://localhost:8000` (Default)

---

## ğŸ“¡ Endpoints

### 1. Chat & Stream (`POST /chat/stream`)
This is the main endpoint. It establishes a persistent connection to stream agent activities.

**Method:** `POST`  
**Content-Type:** `application/json`  
**Response Type:** `text/event-stream` (SSE)

#### A. Starting a New Conversation
Send this payload when the user types a message.

```json
{
  "message": "Send an email to Younes...",
  "thread_id": "unique_session_id_123",
  "resume_action": null
}
```

#### B. Resuming after an Interrupt (Approval/Feedback)
Send this payload when the user approves a draft or requests changes. Note that `message` is null here.

```json
{
  "message": null,
  "thread_id": "unique_session_id_123",
  "resume_action": "approved" 
  // OR: "change_requested: Please add 'Best regards'..."
}
```

---

## ğŸŒŠ Streaming Events (SSE)

The server pushes named events. Your EventSource client should listen for these specific event types.

### Event Types

| Event Name | Description | Data Structure |
| :--- | :--- | :--- |
| **`agent_start`** | Fired when the active agent switches (e.g., from Supervisor to Email Agent). | `{"agent": "email_agent"}` |
| **`token`** | A chunk of text generated by the LLM. Append this to the UI to create a typing effect. | `{"agent": "email_agent", "text": "Hello "}` |
| **`tool_call`** | Fired when an agent decides to use a tool (e.g., checking calendar). Useful for showing spinners/status updates. | `{"agent": "calendar_agent", "tool": "get_events", "args": {...}}` |
| **`interrupt`** | **CRITICAL:** The graph has PAUSED. It needs user input (e.g., approve draft). Display the payload to the user. | `{"type": "review_required", "payload": "Markdown string of draft..."}` |
| **`done`** | The workflow has finished successfully. | `"success"` |
| **`error`** | Something went wrong server-side. | `{"error": "Error details..."}` |

---

## ğŸ’» Frontend Implementation Guide

### JavaScript / TypeScript Example (using `fetch_event_source`)

Standard `EventSource` doesn't support POST requests natively. It is highly recommended to use the **`@microsoft/fetch-event-source`** library.

```bash
npm install @microsoft/fetch-event-source
```

#### Code Snippet

```javascript
import { fetchEventSource } from '@microsoft/fetch-event-source';

const THREAD_ID = "user-session-1";

async function sendMessage(userMessage) {
    await streamChat({ 
        message: userMessage, 
        thread_id: THREAD_ID 
    });
}

async function sendApproval(decision) {
    // decision = "approved" OR "change_requested: fix typo"
    await streamChat({ 
        resume_action: decision, 
        thread_id: THREAD_ID 
    });
}

async function streamChat(payload) {
    await fetchEventSource('http://localhost:8000/chat/stream', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        
        onmessage(msg) {
            // 1. Parse Data
            const data = msg.data ? JSON.parse(msg.data) : null;

            // 2. Handle Events
            if (msg.event === 'agent_start') {
                console.log(`ğŸ¤– Agent Active: ${data.agent}`);
                // Update UI to show who is "thinking"
            } 
            
            else if (msg.event === 'token') {
                // Append text to chat window
                appendToChat(data.text);
            } 
            
            else if (msg.event === 'tool_call') {
                console.log(`ğŸ› ï¸ Tool Used: ${data.tool}`);
                // Show a loading spinner
            }
            
            else if (msg.event === 'interrupt') {
                console.log("âš ï¸ Review Required");
                // 1. Show Modal with `data.payload` (Markdown Email Draft)
                // 2. Add 'Approve' / 'Changes' buttons
                // 3. When clicked, call sendApproval()
                showReviewModal(data.payload);
            }
            
            else if (msg.event === 'done') {
                console.log("âœ… Stream Complete");
            }
        },
        
        onerror(err) {
            console.error("Stream Error", err);
        }
    });
}
```

---

## ğŸ§  Logic Flow for Interrupts

1.  **Normal Flow:** User sends message -> Server streams tokens -> Server sends `done`.
2.  **Interrupt Flow:**
    *   User sends "Send email to Alice".
    *   Server streams agent tokens...
    *   Server sends **`interrupt`** event containing the email draft.
    *   **Server connection closes/stops sending.** (Graph is paused state).
    *   Frontend displays the draft in a modal.
    *   User clicks "Approve".
    *   Frontend makes a **NEW** POST request with `resume_action: "approved"`.
    *   Server resumes streaming (Sending email...) -> Server sends `done`.

## ğŸ›  Status Check
`GET /health`
Returns `{"status": "ok"}` if the API is running.